from pathlib import Path
import sys
import argparse
import warnings
import numpy as np
from scipy.interpolate import Akima1DInterpolator
import h5py
import time


def N_read_line(ff, N):
    """
    Auxilliary routine to help reading lines from the opacity table file.
    Written by MHM.

    Parameters 
    ----------
    ff : TextIOWrapper
    N : int

    Returns
    -------
    vec : ndarray
        Output vector.
    """
    nline = 6
    dum = N/float(nline)
    Nlines = int(N/nline)
    dN = N % nline
    if dN > 0:
        Nlines = Nlines + 1
    line_tot = ''
    for i in range(Nlines):
            line = ff.readline()
            line_tot = line_tot + line
    vec = np.array(list(map(float,line_tot.split())))
    return vec



def ht_read(table):
    """
    Reads the opacity table and returns the opacity ``opac`` at the
    wavelengths and frequencies ``wave`` and ``freq``, respectively
    Written by MHM.

    Parameters 
    ----------
    table : str
        File containing ascii files of opacities generated by Tlusty.
    Returns
    -------

    """
    print('Reading opacity table: ',table)
    ftab = open(table,'r')
    ifreq = 0
    for line in ftab:
        if 'number of frequencies' in line:
            line = ftab.readline()
            Nfreq = int(line.split()[0])
            Ntemp = int(line.split()[1])
            Nden  = int(line.split()[2])
        if 'log temperatures' in line:
            lt_vec = N_read_line(ftab,Ntemp)
            t_vec  = np.exp(lt_vec)
        if 'log densities' in line:
            lrho_vec = N_read_line(ftab,Nden)
            rho_vec  = np.exp(lrho_vec)
        if 'log electron densities' in line:
            ln_e_vec = N_read_line(ftab,Ntemp * Nden)
            n_e_vec  = np.exp(ln_e_vec)
        # allocate master opacity array
            opac = np.zeros((Nden,Ntemp,Nfreq))
            wave = np.zeros((Nfreq))
            freq = np.zeros((Nfreq))
        if '*** frequency' in line:
            wave[ifreq] = float(line.split()[-1])
            line = ftab.readline()
            freq[ifreq] = float(line.split()[0])
            for iden in range(Nden):
                t_index = N_read_line(ftab,Ntemp)
                opac[iden,:,ifreq] = t_index
            ifreq = ifreq + 1
    return Nfreq, Ntemp, Nden, lt_vec, lrho_vec, ln_e_vec, wave, freq, opac


def getPlasmaGrid(opacdir='.', infile='', rhol=None, rhoh=None, Tl=None, Th=None,
                   wvl=None, wvh=None, dwv=0.01):
    """
    Generate grid of wavelength dependent opacities from Tlusty single
    temperature/density (slab mode) models.

    Interpolate opacity to regular wavelength grid with spacing ``dwv`` and
    return grid of opacities with specified rho, T, and wavelength
    bounds.

    Parameters 
    ----------
    opacdir : str
        Directory containing ascii files of opacities generated by Tlusty.
    infile : str
        Name of file containing opacities generated by Tlusty.
    rhol : float
        Lower bound on density for output grid.  If not specified, use min
        density found in input files.
    rhoh : float
        Upper bound on density for output grid.  If not specified, use max
        density found in input files
    Tl : float
        Lower bound on T for output grid.  If not specified, use min T
        found in input files.
    Th : float
        Upper bound on T for output grid.  If not specified, use max T
        found in input files.
    wvl : float
        Lower bound on wavelength for output grid (in Angstrom).  If not
        specified, use 900. Ang.
    wvh : float
        Upper bound on wavelength for output grid (in Angstrom).  If not
        specified, use 21000. Ang.
    dwv : float
        Wavelength spacing for interpolated output (in Angstrom)
    
    Returns
    -------
    wint : ndarray
        Output wavelength array (in Angstroms) from ``wvl`` to ``wvh`` with
        regular spacing ``dwv``.
    rho_vec : ndarray
        Output vector of unique rho values in ascending order
    t_vec : ndarray
        Output vector of unique T values in ascending order
    opac_m : ndarray
        Output array of opacities interpolated to regular wavelength interval
        using :py:class:`scipy.interpolate.Akima1DInterpolator`
        Shape is (len(``wint``), len(``rho_vec``), len(``t_vec``)).
    n_e_vec : ndarray
        Output array of electron densities.
        Shape is (len(``rho_vec``), len(``t_vec``))
    filesize : float
        Crude estimate of the output file size in MB.

    Raises
    ------
    IOError
        If the input directory or files do not exist.
    ValueError
        If any input bounds are outside the grid values
    """

    p = Path(opacdir)

    if not p.exists():
        message = 'Directory {} does not exist'.format(opacdir)
        raise IOError(message)

    file = p / infile

    if not file.exists():
        message = 'File {} does not exist in specified directory'.format(infile)
        raise IOError(message)

    if wvl is None:
        wvl = 900.
        print('Setting min wavelength to {:f.2} Ang'.format(wvl))
    if wvh is None:
        wvh = 21000.
        print('Setting max wavelength to {:f.2} Ang'.format(wvh))

    wint = np.arange(wvl, wvh, dwv)
    nw = len(wint)
    # spec = np.zeros((nw, nspec))

    Nfreq, Ntemp, Nden, lt_vec, lrho_vec, ln_e_vec, wave, freq, opac_arr = ht_read(file)

    t_vec = np.exp(lt_vec)       # The vector of temperatures (in K)
    rho_vec = np.exp(lrho_vec)   # The vector of densities (in g/cm^3)
    n_e_vec = np.exp(ln_e_vec).reshape((Ntemp, Nden)).T   # The array (Nden, Ntemp) of electron densities (in electrons/cm^3)

    rhomin = np.min(rho_vec)
    rhomax = np.max(rho_vec)
    tmin = np.min(t_vec)
    tmax = np.max(t_vec)

    # Warn if requested bounds are broader than grid
    if rhomin > rhol:
        message = ('Minimum density in input file grid is {:g}, which is greater '
                    'than the desired minimum, {:g}.  '
                    'Using {:g}'.format(rhomin, rhol, rhomin))
        warnings.warn(message)

    if rhomax < rhoh:
        message = ('Maximum density in input file grid is {:g}, which is less '
                    'than the desired maximum, {:g}.  '
                    'Using {:g}'.format(rhomax, rhoh, rhomax))
        warnings.warn(message)

    if tmin > Tl:
        message = ('Minimum T in input file grid is {:g}, which is greater '
                    'than the desired minimum, {:g}.  '
                    'Using {:g}'.format(tmin, Tl, tmin))
        warnings.warn(message)

    if tmax < Th:
        message = ('Maximum T in input file grid is {:g}, which is less '
                    'than the desired maximum, {:g}.  '
                    'Using {:g}'.format(tmax, Th, tmax))
        warnings.warn(message)

    if rhol is None:
        rhol = rhomin
    if rhoh is None:
        rhoh = rhomax
    if Tl is None:
        Tl = tmin
    if Th is None:
        Th = tmax

    ep = 1.e-8
    gcond = (rho_vec >= (rhol - ep)) & (rho_vec <= (rhoh + ep))
    ep = .1
    tcond = (t_vec >= (Tl - ep)) & (t_vec <= (Th + ep))

    if not any(gcond):
        message = ('No density values in input file grid are within the desired ' 
                   'output range.')
        raise ValueError(message)

    if not any(tcond):
        message = ('No T values in input file grid are within the desired ' 
                   'output range.')
        raise ValueError(message)

    indg = np.nonzero(gcond == 0)
    indt = np.nonzero(tcond == 0)

    opac_0 = np.delete(opac_arr, indg, 0)
    opac_m = np.delete(opac_0, indt, 1)

    print('opac_mshape', opac_m.shape)

    rho_vec = rho_vec[gcond]
    t_vec = t_vec[tcond]

    ng = len(rho_vec)
    nt = len(t_vec)
    print('wint', len(wint))
    # interpolate grid to even wavelength spacing
    opac_arr_int = np.zeros((len(wint), ng, nt))
    for i in range(ng):
        for j in range(nt):
            akima_wv_op = Akima1DInterpolator(wave, opac_m[i, j])
            opac_arr_int[:, i, j] = akima_wv_op(wint)
            j = j + 1
        i = i + 1
    print(opac_arr_int.shape)
    filesize = opac_arr_int.nbytes + wint.nbytes + t_vec.nbytes + rho_vec.nbytes
    filesize = filesize/(1024.*1024.)
    print('Output grid file will be approx. {:g} MB'.format(filesize))
    print('and contain {:g} spectra at {:g} density points and {:g} T '
          'points.'.format(ng*nt, ng, nt))

    return wint, rho_vec, t_vec, opac_arr_int, n_e_vec, filesize
    

def writehdf(wv, gvec, tvec, flux, nev, filename='TlustyPlasmaGrids.hdf5',
             grid_name='default', writehead=False):
    """
    Writes opacity grid to hdf5 file in format suitable to be read by
    :py:func:`WDmodel.io.read_model_grid`. Prompts user if file already exists.

    Parameters
    ----------
    wv : array-like
        Wavelength array (in Angstroms).
    gvec : array-like
        Vector of density values in ascending order
    tvec : array-like
        Vector of T values in ascending order
    flux : array-like
        Array of opacities with shape (len(``wv``), len(``gvec``), len(``tvec``)).
    nev : array-like
        Array of electron density with shape (len(``gvec``), len(``tvec``)).
    filename : str
        Name of output hdf5 file.
    grid_name : str
        Name of output group containing grid.
    writehead : bool
        If ``True``, include hardwired header info in hdf5 attributes.
    
    Notes
    -----
    Header infomration, including units, is hardwired and specific to the
    Tlusty slab mode models.
    """
    print('fluxshape ', flux.shape)

    if Path(filename).is_file():
        message = '{} already exists.  Do you want to overwrite? (y/n) '.format(filename)
        if input(message).lower() != 'y':
            message = 'Input new filename: '
            filename = input(message)

    hf = h5py.File(filename, 'w')
    g = hf.create_group(grid_name)

    # in Angstroms, equally spaced
    g.create_dataset('wave', data=wv)

    g.create_dataset('ggrid', data=gvec)
    g.create_dataset('tgrid', data=tvec)

    # flux is Nwave x Nggrid x Ntgrid
    g.create_dataset('flux', data=flux)

    # ne is Nrho x Ntemp
    g.create_dataset('negrid', data=nev)

    if writehead:
        info = ('Model opacities from Tlusty (I. Hubeny) slab mode '
                'spline interpolated onto regular wavelength grid. Fromatted '
                'for use with WDmodel python package.')
        g.attrs['info'] = info
        g['wave'].attrs['unit'] = 'Angstrom'
        g['ggrid'].attrs['unit'] = 'g/cm^3'
        g['tgrid'].attrs['unit'] = 'Kelvin'
        g['flux'].attrs['unit'] = 'cm^2/g'
        g['negrid'].attrs['unit'] = 'electrons/cm^3'
        g['wave'].attrs['description'] = 'wavelength'
        g['ggrid'].attrs['description'] = 'density'
        g['tgrid'].attrs['description'] = 'temperature'
        g['flux'].attrs['description'] = 'opacity'
        g['negrid'].attrs['description'] = 'electron density (from EOS assuming LTE)'


def main(inargs=None):
    """
    Get command line options and pass to :py:func:`makeKoesterGrid`, which
    returns spectral grid on regular wavelength interval.
    Passes wavelength, rho, T, and opacity arrays to :py:func:`writehdf` to
    write out grid if ``write`` is ``True``.
    Prompts to confirm write if file size is > ~500 MB.

    Parameters
    ----------
    inargs : array-like
        list of the input command line arguments
    """

    if inargs is None:
        inargs = sys.argv[1:]

    parser = argparse.ArgumentParser()

    parser.add_argument('--rhol',  required=False, type=float, default=5.2e-9,
                        help="density (in g/cm^3) lower bound for output grid")
    parser.add_argument('--rhoh',  required=False, type=float, default=2.48e-6,
                        help="density (in g/cm^3) upper bound for output grid")
    parser.add_argument('--Tl',  required=False, type=float, default=2999.,
                        help="T lower bound for output grid")
    parser.add_argument('--Th',  required=False, type=float, default=30001.,
                        help="T upper bound for output grid")
    parser.add_argument('--dir',  required=False, type=str, default='.',
                        help="directory containing file with Tlusty "
                        "slab mode opacities")
    parser.add_argument('--infile',  required=False, type=str,
                        default='ht4_lemke_ext_dens.dat',
                        help="filename with opacity data")
    parser.add_argument('--wvl',  required=False, type=float, default=3500.,
                        help="Lower bound for output grid wavelength "
                        "(in Angstroms)")
    parser.add_argument('--wvh',  required=False, type=float, default=5300.,
                        help="Upper bound for output grid wavelength "
                        "(in Angstroms)")
    parser.add_argument('--dwv',  required=False, type=float, default=.5,
                        help="Wavelength spacing (in Angstroms) for "
                        "output grid")
    parser.add_argument('--outfile',  required=False, type=str,
                        default='TlustyPlasmaGrids.hdf5',
                        help="output filename for hdf5 file containing grid")
    parser.add_argument('--outgroup',  required=False, type=str,
                        default='default',
                        help="output group name in hdf5 file to contain grid")
    parser.add_argument('--write',  required=False, action='store_true',
                        help="Write out hdf5 file.")
    parser.add_argument('--header',  required=False, action='store_true',
                        help="Include attribute info in hdf5 file.")

    args = parser.parse_args()

    rhol = args.rhol
    rhoh = args.rhoh
    Tl = args.Tl
    Th = args.Th
    opacdir = args.dir
    infile = args.infile
    wvl = args.wvl
    wvh = args.wvh
    dwv = args.dwv
    filename= args.outfile
    grid_name = args.outgroup
    write = args.write
    header = args.header

    wint, rhov_m, tv_m, specrs_m, nev, fsz = getPlasmaGrid(
        opacdir=opacdir, infile=infile, rhol=rhol, rhoh=rhoh, Tl=Tl, Th=Th,
        wvl=wvl, wvh=wvh, dwv=dwv)

    # The ne value of the lowest density (0), highest temp (-1) point is
    # obviously wrong. This is an interpolated value to fix that, but this
    # will only be correct for a grid where the highest temp is 30000 and the
    # lowest density is rho = 5.25e-9. This is probably a problem with writing
    # writing out the synspec slab mode file since with the smaller grid the
    # bad point was still at the lowest density, highest temp, even though this
    # was a different density.
    nev[0,-1] = 3.09799592e15

    if write & (fsz > 500.):
        message = 'Would you like to proceed with writing file to disk? (y/n) '
        if input(message).lower() != 'y':
            write = False

    if write:
        writehdf(wint, rhov_m, tv_m, specrs_m, nev, filename=filename,
                 grid_name=grid_name, writehead=header)


if __name__=='__main__':
    inargs = sys.argv[1:]
    main(inargs)

